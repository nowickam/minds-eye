<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script src="https://d3js.org/d3.v7.js"></script>
    <script src="./lib/three.js"></script>
    <style>
        svg {
            width: 100%;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            visibility: hidden;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        line {
            stroke: #ccc;
        }

        text {
            text-anchor: middle;
            font-family: "Helvetica Neue", Helvetica, sans-serif;
            fill: rgb(0, 0, 0);
            font-size: 10px;
        }

        circle {
            stroke: #fff;
            fill-opacity: 0.5;
        }
    </style>
</head>

<body>
    <div id="content">
        <canvas id="c"></canvas>
        <svg width="400" height="300">
            <g id="main">
                <g class="links"></g>
                <g class="nodes"></g>
            </g>
        </svg>
    </div>
    <script>
        const width = window.innerWidth,
            height = window.innerHeight;


        Promise.all(
            ["nodes.csv", "links.csv"].map((filename) => d3.csv(filename))
        ).then((graphData) => {
            console.log(graphData);
            const [nodes, links] = graphData;
            let nodesShader = []
            let linksShader = []
            let width = window.innerWidth;
            let height = window.innerHeight;

            function main() {
                const canvas = document.getElementById('c');
                canvas.width = width;
                canvas.height = height;

                const renderer = new THREE.WebGLRenderer({ antialias: true, canvas: canvas, alpha: true });
                renderer.setClearColor(0x000000, 0);
                renderer.setSize(width, height)

                const camera = new THREE.OrthographicCamera(
                    -1, // left
                    1, // right
                    1, // top
                    -1, // bottom
                    -1, // near,
                    1, // far
                );

                const scene = new THREE.Scene();
                const plane = new THREE.PlaneBufferGeometry(2, 2);

                const vertexShader = /* glsl */ `
                            varying vec3 vUv;
                            void main() {
                                gl_Position = vec4(position, 1.0 );
                            }
                `

                const fragmentShader = /* glsl */ `
                            #define POINTS 115
                            #define LINKS 490
                            #define COLORS 5
                            #define PI 3.1415
            
                            uniform vec2 u_resolution;
                            uniform float u_time;
                            uniform vec4 u_nodes[POINTS];
                            uniform vec4 u_links[LINKS];
                            
                            float random(vec2 co) {
                                return fract(sin((mod(dot(co, vec2(12.9898, 78.233)), 2.*PI))) * 43758.5453);
                            }
            
            
                            // https://thebookofshaders.com/11/
                            float noise (in vec2 st) {
                                vec2 i = floor(st);
                                vec2 f = fract(st);
            
                                // Four corners in 2D of a tile
                                float a = random(i);
                                float b = random(i + vec2(1.0, 0.0));
                                float c = random(i + vec2(0.0, 1.0));
                                float d = random(i + vec2(1.0, 1.0));
            
                                // Smooth Interpolation
            
                                // Cubic Hermine Curve.  Same as SmoothStep()
                                vec2 u = f*f*(3.0-2.0*f);
                                // u = smoothstep(0.,1.,f);
            
                                // Mix 4 coorners percentages
                                return mix(a, b, u.x) +
                                        (c - a)* u.y * (1.0 - u.x) +
                                        (d - b) * u.x * u.y;
                            }
            
                            float map(float value, float min1, float max1, float min2, float max2) {
                                return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
                            }
            
                            int getColorIdx(vec2 idx, int chromPos){
                                // random decreased res (bigger values of the final multiplier mess the color sequence connection with js)
                                float val = 10.*fract(sin(dot(vec2(idx.x+float(chromPos),idx.y+float(chromPos)), vec2(11.28, 78.23)))* 43.83);
                                float valMod = mod(val, float(COLORS));
                                float valModFloor = floor(valMod);
                                        
                                return int(valModFloor);
                            }

                            float line( in vec2 p, in vec2 a, in vec2 b ){
                                vec2 ba = b-a;
                                vec2 pa = p-a;
                                float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
                                return length(pa-h*ba)-0.1; // use actual length

                                // or use length squared
                                // vec2 sqrd = pa-h*ba;
                                // sqrd = sqrd * sqrd;
                                // return sqrd.x+sqrd.y;
                            }

                            float sdSegment( in vec2 p, in vec2 a, in vec2 b )
                            {
                                vec2 pa = p-a, ba = b-a;
                                float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
                                return length( pa - ba*h );
                            }
                            
                            void main() {
                                // Normalized pixel coordinates (from 0 to 1)
                                vec2 uv = gl_FragCoord.xy / u_resolution;
                                uv.x *= u_resolution.x / u_resolution.y;
                                        
                                vec2 seed = vec2(0.);
                                vec2 seedY = vec2(1.);
                            
                                vec3 colors[COLORS+1];
                                // colors[0] = vec3(214., 189., 232.) / 255.;
                                colors[0] = vec3(114., 89., 132.) / 255.;
                                colors[1] = vec3(59., 43., 89.) / 255.;
                                colors[2] = vec3(82., 0., 211.) / 255.;
                                colors[3] = vec3(115., 133., 255.) / 255.;
                                colors[4] = vec3(137., 184., 196.) / 255.;
                                colors[5] = vec3(188., 191., 196.) / 255.;
                            
                                // Centroids
                                vec2 points[POINTS];
                                for (int i = 0; i < POINTS; i++) {
                                // points[i] = vec2(1.*noise(seed),map(float(i) / float(POINTS), 0., 1., 0., .915));
                                // // points[i] = vec2(noise(seed), map(noise(seedY), 0., 1., 0., .7));
                                // //   points[i] = vec2(random(vec2(seed.x), random(seed.y));
                                // seed += .5;
                                // seedY += .2;
                                points[i] = vec2(u_nodes[i].xy);
                                }
                            
                                // https://www.shadertoy.com/view/ldB3zc
                                // Worley noise with antialiasing (take distance to all centroids proportionally, i think)
                                float d;
                                vec4 m = vec4(8.0, 0.0, 0.0, 0.0);
                                float w = 0.2;
                                float blobSize = 35.;

                                float seedx = 10.;
                                float seedy = 2.;
                                
                                for (int i = 0; i < POINTS; i++) {
                                    d = pow(distance(uv, points[i]), 2.) * blobSize;
                                    // int colorIdx = getColorIdx(seed, i);
                                    int colorIdx = int(u_nodes[i].w);

                                    seedx += 0.15;
                                    seedy += 0.3;
                                
                                    vec3 col = 1. - colors[colorIdx]; // + 0.05 * vec3(random(vec2(seedx, seedy)), random(vec2(seedx+0.03, seedy+0.04)), random(vec2(seedx+0.05, seedy+0.03)));
                                    float h = smoothstep(-1., 1., (m.x - d) / w);
                                    m.x = mix(m.x, d, h) - h * (1.0 - h) * w / (.1 + 3. * w);       // distance
                                    m.yzw = mix(m.yzw, col, h) - h * (1.0 - h) * w / (.1 + 3. * w); // color
                                }

                                float lines = line(uv.xy, u_links[0].xy, u_links[0].zw);

                                for(int i = 1; i < 50; i++){
                                    vec2 a = u_links[i].xy;
                                    vec2 b = u_links[i].zw;
                                    lines *= line(uv.xy, a, b);
                                }
            
                                // Step gradient; 100/100 clean; 80/100 dirty
                                float minDistFlat = floor(m.x * 800.) / 600.;
                            
                                // Edge around 
                                float rim = .005;
                                float thickness = .005;
                                float intensity = .05;
                            
                                minDistFlat -= intensity * (smoothstep(rim - thickness, rim, m.x) -
                                                            smoothstep(rim, rim + thickness, m.x));
                                minDistFlat -= 0.05 * (smoothstep(0. - thickness, 0., m.x) -
                                                    smoothstep(0., 0. + thickness, m.x));
                            
                                // m.x -= intensity * (smoothstep(rim - thickness, rim, m.x) -
                                //                     smoothstep(rim, rim + thickness, m.x));
                            
                                vec3 color = vec3(1.);
                            
                                // color * distance mask
                                color -= m.yzw * (1. - 15. * vec3(minDistFlat));
            
                                // There is a chromosome in the tile and clean the distant background
                                // if(m.x < 100.*rim)
                                // {
                                    //   Add grain
                                    // color -= vec3(.25 * (noise(20.0*uv) - .5));
                                    color -= vec3(.1 * (random(uv) - .5));
            
                                    float alpha = smoothstep(.9, 0.4, color.r);
                                    // alpha -= .55;
                                    alpha = 1.0;
                                    color = vec3(sign(lines));

                                    gl_FragColor = vec4(color, alpha);
                                // }
                                
                            }
                            `;

                let time = 0;

                const uniforms = {
                    u_resolution: { value: new THREE.Vector2(canvas.width, canvas.height) },
                    u_time: { value: time },
                    u_nodes: { value: nodesShader },
                    u_links: { value: linksShader }
                };

                const material = new THREE.ShaderMaterial({
                    vertexShader: vertexShader,
                    fragmentShader: fragmentShader,
                    uniforms: uniforms,
                    transparent: true,
                });
                scene.add(new THREE.Mesh(plane, material));

                function render(time) {
                    time *= 0.001;
                    uniforms.u_time.value = time;

                    renderer.render(scene, camera);

                }

                requestAnimationFrame(render);
            }

            const simulation = d3
                .forceSimulation(nodes)
                .force("charge", d3.forceManyBody().strength(-50))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .force(
                    "link",
                    d3
                        .forceLink(links)
                        .id(function (d) {
                            return d.name;
                        })
                        .distance(50)
                )
                .on("tick", ticked);

            function updateLinks() {
                const u = d3
                    .select(".links")
                    .selectAll("line")
                    .data(links)
                    .join("line")
                    .attr("x1", function (d) {
                        return d.source.x;
                    })
                    .attr("y1", function (d) {
                        return d.source.y;
                    })
                    .attr("x2", function (d) {
                        return d.target.x;
                    })
                    .attr("y2", function (d) {
                        return d.target.y;
                    });
            }
            const nodeGeometry = d3
                .select(".nodes")
                .selectAll("g.nodeGeometry")
                .data(nodes)
                .join("g")
                .classed("nodeGeometry", true);
            const logOfRelevance = d3
                .scaleLog()
                .domain(d3.extent(nodes, (d) => +d.nodesize))
                .range([1, 30]);
            const palette = [
                "#7c1158",
                "#bd7ebe",
                "#1a53ff",
                "#ea5545",
                "#f46a9b",
                "#ef9b20",
                "#edbf33",
                "#ede15b",
                "#bdcf32",
                "#fdcce5",
                "#27aeef",
                "#b33dc6",
                "#fd7f6f",
            ];

            nodeGeometry
                .append("circle")
                .attr("r", function (d) {
                    return logOfRelevance(d.nodesize);
                })
                .attr("fill", (d) => palette[d.group]);
            nodeGeometry.append("text").text((d) => d.name);

            function updateNodes() {
                d3.select(".nodes")
                    .selectAll("g.nodeGeometry")
                    .attr("transform", (d) => `translate(${d.x},${d.y})`);
            }

            function updateNodesShader() {
                nodesShader = simulation.nodes().map((d) =>
                    // (x adjusted for resolution, y inverted, r scaled accrding to plot)
                    new THREE.Vector4(d.x / width * width / height, 1 - d.y / height, logOfRelevance(d.nodesize), parseInt(d.group) % 6)
                )
            }

            function updateLinksShader() {
                linksShader = links.map((d) =>
                    new THREE.Vector4(d.source.x / width * width / height, 1 - d.source.y / height,
                        d.target.x / width * width / height, 1 - d.target.y / height)
                )
            }

            function ticked() {
                updateLinks();
                updateNodes();

                updateNodesShader();
                updateLinksShader();

                main();
            }

            //ZOOM and PAN
            // let svg = d3.select("#content");
            // svg = svg.call(d3.zoom().on("zoom", zoomed)).select("g");
            // function zoomed(e) {
            //   const { x, y, k } = e.transform;
            //   svg.attr(
            //     "transform",
            //     "translate(" + x + "," + y + ")" + " scale(" + k + ")"
            //   );
            // }
        });
    </script>
</body>

</html>